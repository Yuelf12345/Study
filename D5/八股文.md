一、CSS
    1.说一下CSS的盒模型。
        在HTML页面中的所有元素都可以看成是一个盒子
        盒子的组成：内容content、内边距padding、边框border、外边距margin
        盒模型的类型：
            标准盒模型
                margin + border + padding + content
            IE盒模型
                margin + content(border + padding)
        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;
    2.CSS选择器的优先级？
        CSS的特性：继承性、层叠性、优先级
        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式
        标签、类/伪类/属性、全局选择器、行内样式、id、!important
        !important > 行内样式 > id > 类/伪类/属性 > 标签 > 全局选择器
    3.隐藏元素的方法有哪些？
        display:none;
            元素在页面上消失，不占据空间
        opacity:0;
            设置了元素的透明度为0，元素不可见，占据空间位置
        visibility:hidden;
            让元素消失，占据空间位置，一种不可见的状态
        position:absolute;
        clip-path
    4.px和rem的区别是什么？
        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度
        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;
            1rem = 10px; （16px*62.5%=10px）
    5.重绘重排有什么区别？
        重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小
        重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制
        浏览器的渲染机制
        对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排
        对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘
    6.让一个元素水平垂直居中的方式有哪些？
        1.定位+margin
        2.定位+transform
        3.flex布局
        4.grid布局
        5.table布局
    7.CSS的哪些属性哪些可以继承？哪些不可以继承？
        CSS的三大特性：继承、层叠、优先级
        子元素可以继承父类元素的样式
        1.字体的一些属性：font
        2.文本的一些属性：line-height
        3.元素的可见性：visibility:hidden
        4.表格布局的属性：border-spacing
        5.列表的属性：list-style
        6.页面样式属性：page
        7.声音的样式属性
    8.有没有用过预处理器？
        预处理语言增加了变量、函数、混入等强大的功能
        SASS  LESS
        


二、JavaSscipt
    1.JS由哪三部分组成？
        ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），
        文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档
        浏览器对象模型（BOM）：对浏览器窗口进行访问和操作
    2.JS有哪些内置对象？
        Date,Math,Array
    3.操作数组的方法有哪些？
        push,pop,unshift,shift,reverse,sort,splice,slice,concat,map,join,some,ervey,reduce,filter
    4.JS对数据类的检测方式有哪些？
        typeof,instanceof,Object.prototype.toString.call
#    5.说一下闭包，闭包有什么特点？
        简单来说就是函数嵌套函数,内部函数访问外部函数变量;作用特点:保护(形成私有作用域不受外界干扰),保存(不被垃圾回收机制回收)
    6.前端的内存泄漏怎么理解？
        函数运行时系统会分配内存,函数运行完毕后释放内存,由于闭包的特殊原理,函数运行后内存不会被释放,累计多了就会造成内存泄漏
    7.事件委托是什么？
        原理是基于DOM元素的事件冒泡,子元素触发事件后,父元素也会被触发
    8.基本数据类型和引用数据类型的区别？
        基本数据类型存储在栈里,引用数据类型值存储在堆内存,地址存储在栈里
#    9.说一下原型链。
        js创建对象的时候，都有一个内置属性proto指向创建它的函数对象的原型对象prototype;原型对象也是一个对象，它也有一个proto指向prototype;当我们查找一个属性的时候，先去在这个对象里查找，没有的话就去他的原型对象里查找，在没有就去原型对象的原型对象里查找，这样一层一层往上找的过程就形成了原型链。
    10.new操作符具体做了什么？
        创建一个空对象,空对象的proto指向构造函数的prototype,构造函数的this指向空对象,判断返回值,是引用类型就返回该值,不是返回该对象
    11.JS是如何实现继承的？
        原型链,构造函数,组合继承,原型式,寄生(Object.create()),寄生组合,ES6(extends super)
    12.JS的设计原理是什么？
        单线程
#    13.JS中关于this指向的问题
        this是JavaScript中的一个关键字，它是函数运行时，在函数体内自动生成的一个对象，只能在函数体内部使用。
        1. 全局作用域下的this指向window对象;
        2. 函数中的this,指向调用该函数的对象;简单调用该函数时(非显式/隐式绑定下),严格模式下this绑定到undefined,否则绑定到全局对象window/global;
        3. 如果函数调用时被apply,call, bind方法强绑定了this, this就指向强绑定的对象;
        4. 箭头函数没有自己的this, 只能从作用域链的上一层获取this;它总是指向其最近的外层函数作用域的 this 所指对象。
    14.script标签里的async和defer有什么区别？
        都是异步加载,async加载完成后立即执行,会影响DOM渲染;defer会在DOM渲染完成后执行,
    15.setTimeout最小执行时间是多少？
        setTimeout的最短时间间隔是4毫秒: setInterval的最短间隔时间是10毫秒
    16.ES6和ES5有什么区别？
        1、变量声明方式不同：ES5使用var关键字进行变量声明，而ES6则引入了let和const关键字来声明变量。
        2、块级作用域：在ES5中，只存在全局作用域和函数作用域，而ES6中增加了块级作用域，对于if、for、switch等代码块内部所声明的变量，在外部是不可见的。
        3、箭头函数：ES6中新增了箭头函数，可以更为简洁地定义函数，同时箭头函数没有自己的this，它的this绑定在父级作用域的this上。
        4、字符串模板：ES6中新增了字符串模板功能，可以使用反引号（`）来定义多行文本和嵌入表达式。
        5、类和继承：ES6中引入了class关键字来实现类和继承，使得面向对象编程更加方便。
        6、模块化：ES6中引入了模块化的概念，通过export和import关键字来实现模块的导出和引入。
        7、解构赋值：ES6中引入了解构赋值语法，可以方便地从数组或对象中提取值并赋给变量。
        8、Promise对象：ES6中引入了Promise对象，可以更加优雅地处理异步操作。
        9、其他：ES6还新增了一些新的数据结构和方法，如Set、Map、Symbol等。同时对于函数参数的默认值、rest参数等也进行了增强和优化。
    17.ES6的新特性有哪些？
    18.call,aply,bind三者有什么区别？
        1.call和bind 以数组形式接收参数
        2.call和aply 立即执行,bind返回一个函数需要调用
    19.用递归的时候有没有遇到什么问题？
    20.如何实现一个深拷贝？
        1._deepCopy 递归赋值
        2.JSON.stringify + JSON.parse
        3.Object.assgin
#    21.说一下事件循环。
        1.js是单线程语言,必须等到上一个任务执行完才能继续执行下一个,这样会造成阻塞,所以引入了异步任务.js里有一个执行栈
        2.整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
        3.遇到同步任务,就直接放入执行栈里执行
        4.遇到异步任务,会再次分为宏任务和微任务分别放入不同队列
        5.当主线程内的任务执行完毕(主线程为空时)，会检查微任务的任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行\
        6.每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是Event Loop
    22.ajax是什么？怎么实现的？
        1.异步的JS和XML;可以在不重新加载整个网页的情况下,与服务器交换数据 并更新部分网页
        2.通过XMLHttpRequest()构造函数用于初始化一个xhr实例对象,提供open()方法与服务端建立连接;send()方法发送给服务器端;onreadystatechange事件监听服务器端你的通信状态;最后接收并处理服务器端向客户端响应的数据结果
    23.get和post有什么区别？
        1.GET是从服务器上获得数据；POST是向服务器传递数据
        2.get，通过拼接url进行传递参数;post，通过body体传输参数
        3.get一般传输数据大小不超过2k-4k;POSt没有限制
        4.get请求是可以缓存的;post请求不可以缓存
    24.promise的内部原理是什么？它的优缺点是什么？
        1.Promise有三种状态： pending(进行中)、fulfilled(已成功)、rejected(已失败)
        2.Promise对象接受一个回调函数作为参数，该回调函数接受两个参数，分别是成功时的回调resolve和失败的时候回调reject,另外resove的参数除了正常值以外，还可能是一个Promise对象的实例；reject的参通常是一个Error对象的实例
        3.then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)
        Promise的优点
            ● Promise 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算，是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象
            ● 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，简化代码，使代码清晰明了
            ● 此外，Promise对象提供统一的接口，使得控制异步操作更加容易
        Promise的缺点
            ● 无法取消Promise，一旦新建它，就会立即执行，无法中途取消
            ● 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
            ● 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
    25.promise和async await的区别是什么？
        1.promise的出现解决了传统callback函数导致的地狱回调问题，但是他的语法导致它纵向发展形成了一个回调链，遇到复杂的业务场景显然是不美观的；
        2.async、await看起来更加简洁，使得异步代码看起来像同步代码，只有await的代码执行完毕后才会执行下面的代码，与promise一样，也是非阻塞的；
        3.async/await基于Promise实现，相当于Promise的升级版，不能用于普通的回调函数；
    26.浏览器的存储方式有哪些？
        1.sessionStorage 只在同一个窗口共享。在不同的浏览器窗口中不共享，即使是同域名。
        2.cookie可以通过domain属性设置可访问的域名，domain下的所有子域名都可共享
        3.localStorage，indexDB 仅在设置下的同域名共享，不受窗口影响。
    27.token存在sessionstorage还是loaclstorage？
        loaclstorage
#    28.token的登录流程。
        1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码
        2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token
        3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面
        4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面
        5、每次调后端接口，都要在请求头中加token
        6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401
        7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面
    29.页面渲染的过程是怎样的？
        1.HTML解析：浏览器首先会读取HTML文件，并将其解析成DOM树(Document Object Model)。DOM树是一个树形结构，它表示了整个文档的内容和结构，包括所有的HTML标签、属性和文本内容。
        2.CSS解析：浏览器接下来会解析CSS文件，并将其中的样式规则应用到DOM树上。这些样式规则可以控制页面的布局、颜色、字体等外观方面的表现。
        JavaScript执行：如果HTML文件中包含了JavaScript代码，那么浏览器会先解析这些代码，并在运行时执行它们。JavaScript代码可以修改DOM树、操作页面元素、处理用户输入等等。
        3.渲染：最后，浏览器会根据DOM树和应用的样式规则来绘制页面。这个过程涉及到多个步骤，包括布局计算、绘制图形、绘制文本等等。最终，浏览器会将渲染好的页面显示在用户的屏幕上。
        需要注意的是，以上步骤并不是线性的，可能会出现交叉执行的情况。例如，当浏览器解析HTML文件时，如果发现其中包含了JavaScript代码，那么它会先执行JavaScript代码，然后再进行后续的解析和渲染操作。
        DOM树 --> CSSOM树 --> rander树 --> 布局 --> 绘制
    30.DOM树和渲染树有什么区别？
        DOM树和渲染树都是浏览器中用于描述页面内容的结构化树形结构，但它们有一些区别。
        DOM树(Document Object Model Tree)是指HTML文档在内存中的表示形式，它将HTML文档中的各个元素以节点的形式进行组织，并通过节点之间的关系来表示文档的结构。DOM树是一种数据结构，它描述了文档的内容和结构，但并不包含任何样式信息。
        渲染树(Render Tree)是浏览器在解析CSS样式后生成的用于表示页面呈现效果的树形结构。渲染树与DOM树不同之处在于，它不仅包含了文档的结构信息，还包含了每个节点的样式信息。渲染树只包含最终的呈现效果所需的信息，而不包含用户交互、动画和其他动态效果所需的信息。因此，渲染树比DOM树更轻量级，可以更快地进行布局和绘制。
        总之，DOM树和渲染树都是用于描述页面内容的结构化树形结构，但它们的用途和包含的信息略有不同。DOM树描述了文档的结构和内容，而渲染树则描述了页面呈现效果所需的信息。
    31.精灵图和base64的区别是什么？
        1.精灵图是将一张图片拆分成多个小块，每个小块都包含了原图的一部分信息，然后通过Base64编码进行传输。而Base64编码是将二进制数据转换成ASCII字符的编码方式，不涉及图像拆分和压缩。
        2.精灵图通常用于在网页中动态加载图片，因为它可以将图片拆分成多个小块，减少了一次性加载大图片对浏览器的压力。而Base64编码则可以用于将二进制数据转换成文本进行传输，例如在邮件中发送文件时。
        3.精灵图的传输速度比Base64编码要快，因为它不需要对二进制数据进行解码和编码。但是，由于精灵图需要将图片拆分成多个小块，所以在传输过程中会增加一些开销。
    32.svg格式了解多少？
        1.可伸缩性：SVG图形可以无限缩放，而不失去清晰度。这使得SVG成为Web设计的理想选择，因为它可以在各种分辨率和屏幕尺寸上保持良好的呈现效果。
        2.矢量表示：SVG图形是由一系列矢量路径和形状组成的，而不是像素点。这意味着即使图像被放大或缩小，其质量和细节也不会丢失
        3.兼容性：几乎所有现代浏览器都支持SVG图形，包括Internet Explorer、Mozilla Firefox、Google Chrome等。此外，许多桌面和移动应用程序也支持SVG图形渲染。
#    33.了解过JWT吗？
        JWT(JSON Web Token)是一种开放标准(RFC 7519),用于在网络应用之间安全地传输信息。它允许用户将其身份验证和授权数据存储在一个紧凑的、自包含的令牌中，而无需将敏感信息发送到服务器或第三方。JWT包含三个部分：头部(Header)、载荷(Payload)和签名(Signature)。其中头部和载荷通常是由应用程序生成并填充的，签名则是由服务器使用密钥对头部和载荷进行加密生成的。
        JWT的主要优点包括：
            安全性：JWT使用数字签名来保护数据的完整性和真实性，防止数据被篡改或伪造。
            无状态：JWT不依赖于客户端与服务器之间的会话状态，因此可以轻松地实现单点登录(SSO)等功能。
            可扩展性：JWT可以轻松地添加新的认证和授权数据，而不需要更新所有相关的客户端代码。
            紧凑性：JWT非常小巧，可以在网络中安全地传输，减少了数据传输的大小和开销。
        总之，JWT是一种安全、可扩展、无状态的令牌格式，适用于各种网络应用中的认证和授权场景。
    34.npm的底层环境是什么？
        npm(Node Package Manager)是一个用于管理Node.js应用程序的包管理器。它的底层环境包括以下几个方面：
            Node.js:npm是Node.js的一部分，它依赖于Node.js运行环境来执行命令和处理文件。因此，在使用npm之前需要先安装Node.js。
            Git:npm使用Git进行版本控制，以便在不同的操作系统和环境中保持一致的安装和管理。
            npm命令行工具：npm提供了一个命令行工具，可以在终端或命令提示符下执行各种操作，如安装、更新、卸载、发布等。
            npm源代码库：npm的源代码库托管在GitHub上，开发人员可以在这里提交问题和请求功能改进。
        总之，npm的底层环境是由Node.js、Git和npm命令行工具组成的。这些组件共同协作，使得npm能够高效地管理和发布Node.js应用程序的依赖关系。
    35.HTTP协议规定的协议头和请求头有什么？
        HTTP协议规定了两个主要的头部：消息头(Message Header)和请求头(Request Header)。
        消息头是HTTP报文中的一部分，包含了一些控制信息，如版本号、状态码、类型等。它位于HTTP报文的最前面，以HTTP/开头，后面跟着版本号，然后是一个空行，最后是其他控制信息
            HTTP/	HTTP版本
            Status-Code	状态码
            Content-Type	内容类型
            Content-Length	内容长度
            Date	日期时间
        请求头则是包含在HTTP请求中的头部信息，用于向服务器传递请求的相关信息。它通常位于消息头之后，以:开头，后面跟着一系列键值对，如下表所示：
            Host	目标主机名
            User-Agent	客户端标识
            Accept	接受的内容类型
            Accept-Language	接受的语言类型
            Referer	引用页面
            Cookie	Cookie信息
        需要注意的是，请求头和消息头可以混合使用，但是不能同时存在相同的字段。例如，可以使用同一个字段来传递多个值，但不能在同一行中同时使用多个相同的字段。
#    36.说一下浏览器的缓存策略。
        浏览器缓存策略是一种机制，用于在浏览器中缓存网页内容以提高页面加载速度和性能。以下是常见的几种缓存策略：
        1. 强缓存(Strong Cache):当服务器第一次发送一个资源请求时，服务器会将资源标记为“强缓存”。这意味着浏览器在后续请求相同资源时，不会向服务器发送请求，而是使用缓存中的版本。强缓存适用于静态资源，如图片、CSS 文件和 JavaScript 文件等。
        2. 协商缓存(Caching-Control):HTTP 响应头中的 `Cache-Control` 字段允许您控制浏览器如何处理缓存。常用的 `Cache-Control` 值包括：
            * `no-cache`:强制浏览器每次都向服务器发送请求。
            * `max-age`:设置缓存的有效期，单位为秒。如果在有效期内再次请求相同的资源，浏览器将使用缓存的内容。
            * `no-store`:禁止浏览器存储缓存。
        3. Expires/Cache-Control:在 HTTP 响应头中设置 `Expires` 或 `Cache-Control`,可以指示浏览器何时应删除缓存中的资源。例如，将 `Expires` 为 `Fri, 31 Dec 9999 23:59:59 GMT` 将导致浏览器在一年后删除缓存的资源。
        为了获得最佳的性能和用户体验，开发人员应该遵循一些最佳实践：
        * 对于静态资源，始终使用强缓存策略。
        * 在可能的情况下，使用长过期时间来减少对服务器的请求次数。
        * 如果必须使用短过期时间，请确保在每次请求时检查 `Date()` 以确保用户处于在线状态。
        * 对于动态生成的内容(如 AJAX),避免使用强缓存策略，并在响应头中设置适当的缓存策略。
#    37.说一下什么是“同源策略”？
        同源策略指的是浏览器的一种安全机制，它要求在同一域名、端口、协议下的所有资源都是可信的。简单来说，同源策略就是限制了网页脚本的访问权限，使得同一域名下的页面才能够相互通信和操作数据。如果两个不同的域名之间进行AJAX请求或JavaScript交互，那么浏览器会拒绝发送请求或接受来自不同域名的响应结果。
        这种安全机制的目的是防止恶意网站通过跨域攻击获取用户的敏感信息，比如登录凭证、信用卡号等。同源策略可以有效地保护用户的隐私和安全。
#    38.防抖和节流是什么？
        防抖和节流都是前端开发中常用的优化性能的技术。
        防抖(debounce)是一种用于处理高频事件的函数节流技术，它会在一定时间内只执行一次函数，如果在这段时间内再次触发事件，则会重新计时。这样可以避免不必要的重复计算，提高性能。
        节流(throttle)也是一种函数节流技术，它会在一定时间内最多执行一次函数，即使在这段时间内多次触发事件，也不会重复执行函数。这样可以控制事件的频率，避免出现卡顿或者崩溃的情况。
        两种技术的实现方式类似，都可以使用闭包来保存函数的状态，以便在下一次执行时恢复状态。选择哪种技术取决于具体的业务场景和需求。
    39.解释一下什么是json？
        JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，用于在客户端和服务器之间传输数据。它基于JavaScript语言的语法和对象模型，并使用简单的文本格式来表示数据结构。
        JSON格式的数据由键值对组成，这些键值对可以是字符串、数字、布尔值、数组或对象等类型。JSON中的键必须是字符串，而值可以是任意类型的数据。
        JSON通常用于Web应用程序中，例如在浏览器端与服务器通信或者在后端编程中处理数据。由于JSON格式简单易懂，且具有广泛的支持，因此已经成为Web开发的标准之一。
    40.当数据没有请求过来的时候，该怎么做？
        当数据没有请求过来时，可以考虑以下几种做法：
            1. 显示空数据：在页面中显示一条提示信息，告诉用户当前没有数据。例如，可以在页面顶部显示一个标题或者弹出框，提示用户正在加载数据。
            2. 加载默认数据：如果应用程序有默认数据，可以在没有获取到最新数据时，显示默认数据。这样可以避免页面空白，同时也可以减少用户的等待时间。
            3. 进行后台数据处理：当数据还没有请求过来时，可以将一些常见的操作放在后台进行处理。例如，更新页面的加载状态、检查是否有新数据等。
            4. 使用计时器：可以使用计时器来控制下一次请求数据的间隔时间。例如，每隔一定时间就发送一次请求，以获取最新的数据。
        无论采用哪种方法，都应该让用户知道当前的状态，以便他们可以做出相应的反应。
    41.有没有做过无感登录？
        1，登录成功后保存token
        2，在响应拦截器中对401状态码引入刷新tokne的方法
        3，获取到新token后，替换掉旧的token
        4，再次发送未完成的请求
    42.大文件上传是怎么做的？
        1，把需要上传的文件按照一定规则，分割成相同大小的数据块
        2，初始化一个分片上传任务，返回本次分片上传的唯一标识
        3，按照一定规则把各个数据块上传
        4，发送完成后，后端会判断上传的完整性，完整的话把数据库合并成原始文件
    43.HTTP状态码中，302、401和502分别代表以下情况：
        1. 302 Found:重定向。表示请求的资源已经被移动到一个新的地址，并且浏览器应该使用新的地址重新发送请求。
        2. 401 Unauthorized:未授权。表示请求需要用户认证或提供凭据才能访问。通常用于API密钥验证或OAuth身份验证等场景。
        3. 502 Service Unavailable:服务不可用。表示服务器暂时无法处理请求，通常是由于过载、维护或其他原因导致的。

三、HTML5CSS3
    1.语义化的理解。
        HTML5 语义化是指在编写 HTML 代码时，将页面内容按照其意义和用途进行分类和标记，以便浏览器能够更好地理解页面的结构和内容，并提供更好的用户体验。
        HTML5 提供了一些新的标签和属性，例如 `<header>`、`<nav>`、`<section>`、`<article>`、`<aside>`、`<footer>` 等，这些标签可以用于表示页面中的不同部分和元素，从而使页面结构更加清晰明了。
        此外，HTML5 还提供了一些新的语义化属性，例如 `itemprop`、`itemtype`、`itemid`、`itemref` 等，这些属性可以用来描述页面中的内容和元素，从而帮助搜索引擎更好地理解页面的意义和用途。
        通过使用 HTML5 的语义化特性，开发人员可以更好地控制页面的结构和内容，提高页面的可读性和可维护性，同时也有助于提高搜索引擎的排名效果。
    2.H5C3有哪些新特性？
        HTML5和CSS3都有很多新特性，下面列举一些主要的：
        HTML5的新特性：
            1. 新的语义化标签：包括header、nav、section、article、aside和footer等，使得页面结构更加清晰明了。
            2. 视频和音频播放功能：可以直接在网页中播放视频和音频文件，不需要跳转到其他页面。
            3. 画布绘图功能：可以使用Canvas API在网页上绘制图形和动画。
            4. 本地存储功能：可以使用Web Storage API在浏览器中保存数据，以便下一次访问时使用。
            5. Web Workers功能：可以在后台运行脚本，不会阻塞网页的加载和渲染。
        CSS3的新特性：
            1. 选择器改进：新增了类伪类、属性选择器等多种选择器，方便开发者对网页元素进行样式控制。
            2. 盒子模型改变：新增了box-sizing属性，可以设置盒子模型的宽度，解决了一些布局问题。
            3. 文本效果增强：新增了文字效果(如文字阴影、渐变色)、字体大小调整等功能，使网页设计更加生动有趣。
            4. 背景和边框控制增强：新增了background-clip属性，可以设置背景的裁剪区域；新增了border-image属性，可以为边框添加图片。
            5. Flexbox布局：可以使用Flexbox布局来实现响应式网页设计，方便开发者进行灵活的布局控制。
    3.rem是如何做适配的？
        rem是一种相对于根元素(html)字体大小的单位，它的大小可以根据屏幕宽度和字体大小进行自动调整。在适配过程中，我们可以通过以下步骤来实现：
            1. 确定根元素字体大小：首先需要确定根元素的字体大小，比如设置为16px。
            2. 计算出根元素的实际宽度：根据设计稿尺寸和设备像素比(device pixel ratio),计算出实际的宽度。例如，设计稿宽度为750px,设备像素比为2,则实际宽度为375px。
            3. 转换rem值为px值：将rem值乘以根元素的实际宽度，得到对应的像素值。例如，假设某个元素的样式设置为font-size: 0.5rem; 则该元素的实际宽度为0.5 * 375px = 187.5px。
            4. 根据屏幕宽度计算rem值：根据不同设备的屏幕宽度，计算出每个rem所对应的像素值。例如，若设备宽度小于等于750px,则1rem等于375px / 750 = 0.5px;若设备宽度大于750px,则1rem等于375px。
            通过以上步骤，我们就可以使用rem来进行适配了。当页面宽度发生变化时，只需要相应地调整根元素的实际宽度和每个rem所对应的像素值即可。这种方式可以实现对不同分辨率的屏幕自动适配，提高了网页的兼容性和可读性。
    4.解决了哪些移动端的兼容问题？
        1.响应式设计：我使用了媒体查询和弹性布局等技术，根据不同设备的屏幕尺寸和方向，自动调整页面布局和样式，以实现对不同设备的适配。例如，我在项目中使用了rem单位来设置字体大小，使得页面可以自适应不同设备的屏幕大小。
        2.图片处理：在移动设备上，图片加载速度很慢，因此需要进行优化处理。我使用了懒加载技术和图片压缩算法来减少页面加载时间和提高用户体验。例如，我使用lazyload.js库来延迟加载图片，并使用imagemin插件对图片进行压缩。
        3.字体处理：在移动设备上，字体显示可能会出现问题，例如过小或者过大。我使用了rem单位来设置字体大小，并使用了@font-face规则来加载自定义字体，以确保在不同设备上字体显示的一致性。
        4.表单处理：在移动设备上，输入表单会变得不太方便，因此需要提供一些便捷的输入方式，如语音输入、手势输入等。我使用了vue-touchless库来实现无障碍键盘输入，并提供了语音输入、手势输入等功能。
        5.JavaScript事件处理：在移动设备上，触摸事件和鼠标事件的行为可能有所不同，因此需要针对不同的事件类型进行处理。我使用了jQuery Mobile框架来处理移动设备的触摸事件，同时也使用了原生JavaScript来处理鼠标事件。
四、Vue
    1.v-if和v-show的区别？
        1.v-if会在第一次渲染时判断条件是否成立，如果成立则添加新的DOM节点，否则不添加。而v-show则是在当前DOM节点上直接修改样式属性来控制显示和隐藏。
        2.v-if会创建一个新的节点，因此在性能方面可能会比v-show略慢一些。而v-show只是修改了样式属性，不会创建新的DOM节点，因此在性能方面可能更好一些。
#    2.如何理解MVVM的？
        MVVM是Model-View-ViewModel的缩写，是一种前端架构模式。它将应用程序的数据、用户界面和业务逻辑分离开来，使得开发人员可以更加容易地维护和扩展应用程序。
        在MVVM中，有三个核心概念：
            1. Model(模型):表示应用程序的数据。它是数据的来源，并且包含对数据的更改方法。
            2. View(视图):表示应用程序的用户界面。它接收来自模型的数据，并将其呈现给用户。
            3. ViewModel(视图模型):处理用户界面和业务逻辑之间的交互。它包含了对数据的操作和转换，以及对用户界面的控制和管理。
        MVVM的核心思想是将数据与视图分离开来，使得开发人员可以将更多的精力放在业务逻辑和用户体验上。通过使用MVVM框架，开发人员可以更加容易地管理复杂的应用程序，并且可以更加高效地进行测试和调试。
    3.v-for中的key值的作用是什么？
        1.唯一标识每个元素：通过为v-for指令中的每个元素指定一个唯一的key值，可以确保每个元素在DOM中都有一个独立的节点，避免出现重复渲染的情况。
        2.改善性能：当需要在循环中修改数组或对象的属性时，使用v-for指令可以减少不必要的更新操作，从而提高应用程序的性能。
        3.方便调试：当出现渲染错误时，通过查看DOM树的结构和每个元素的key值，可以更容易地定位问题所在
#    4.说一下你对vue生命周期的理解。
        在Vue.js中，组件的生命周期是指从组件实例化开始，到组件被销毁为止所经历的一系列方法调用。Vue.js提供了一组生命周期钩子函数，用于在不同的生命周期阶段执行特定的操作。
        以下是Vue.js组件的生命周期钩子函数：
            1. beforeCreate(options):组件实例被创建之前调用，但是数据观测和事件配置等操作还未完成。
            2. created(options):组件实例被创建之后调用，此时可以访问到组件实例，但是还没有挂载到DOM上。
            3. beforeMount(options):组件被挂载到DOM之前调用，此时可以进行一些DOM操作，但是无法访问到组件实例。
            4. mounted(options):组件被挂载到DOM上之后调用，此时可以访问到组件实例并进行DOM操作。
            5. beforeUpdate(options):组件的数据更新时调用，但是当前的更新并不会触发重新渲染。
            6. updated(options):组件的数据更新后调用，此时可以进行一些DOM操作，但是无法访问到组件实例。
            7. beforeDestroy(options):组件即将被销毁之前调用，但是组件实例仍然可用。
            8. destroyed(options):组件被销毁之后调用，此时可以进行一些资源清理操作。
            9. activated(options):组件被激活之前调用，例如在路由切换时。
            10. deactivated(options):组件被取消激活之后调用。
        通过合理地利用这些生命周期钩子函数，我们可以在不同的生命周期阶段执行特定的操作，从而更好地控制组件的状态和行为。
#    5.在created和mounted去请求数据，有什么区别？
        在Vue.js中，created和mounted是组件的生命周期钩子函数。它们都用于在组件实例创建或挂载后执行一些操作，但是它们的执行时机不同，也有一些不同点。
            1. created:在组件实例被创建之后立即调用，但是DOM还没有被渲染到页面上。此时可以访问到组件实例，但是无法访问到组件所在的DOM元素。如果需要在created阶段请求数据并将数据保存到组件实例中，可以使用this.$http或者Vue.prototype.$http等API进行网络请求。
            2. mounted:在组件被挂载到DOM上之后调用，此时可以访问到组件实例并进行DOM操作。如果需要在mounted阶段请求数据并将数据保存到组件实例中，可以直接使用Vue.prototype.$http等API进行网络请求。需要注意的是，如果在mounted阶段进行了DOM操作，可能会导致网络请求被阻塞，因此建议将网络请求放在created阶段进行。
        总的来说，created和mounted都可以用来请求数据，但是它们的适用场景略有不同。如果需要在组件创建后立即获取数据并将其保存到组件实例中，可以使用created钩子函数；如果需要在组件挂载后获取数据并进行DOM操作，可以使用mounted钩子函数。
    6.vue中的修饰符有哪些？
        在 Vue.js 中，修饰符是用于修改或增强组件、指令或其他 Vue 实例的属性和方法的特殊语法。以下是一些常用的 Vue 修饰符：
            * `.lazy`: 用于在 computed 属性中进行懒加载，只有当该属性被访问时才会执行计算。
            * `.once`: 用于创建一个只响应一次的事件监听器。
            * `.sync`: 用于将一个方法变为同步调用，确保它在当前更新周期内完成。
            * `.disposed`: 用于在组件销毁时自动调用指定的方法。
            * `.prop`: 用于定义一个组件的属性，可以设置它的类型和默认值等选项。
            * `.watch`: 用于监听一个或多个变量的变化，并触发相应的方法。
        除了上述修饰符之外，Vue 还提供了许多其他的修饰符，例如 `.model`, `.methods`, `.computed`, `.components` 等等。这些修饰符可以帮助我们更好地控制 Vue 实例的行为和属性。
    7.elementui是怎么做表单验证的？
        elementui使用了一种基于表单原生事件的验证方式。具体来说，它使用了以下步骤：
            1. 在form元素上绑定v-model指令，将用户输入的数据绑定到组件实例的data属性上。
            2. 在每个表单元素上使用el-form-item、el-form-item-prop和el-form-item-tip等组件来构建表单项，并使用v-slot指令将表单项的具体内容渲染到对应的HTML模板中。
            3. 对于每个表单项，使用el-form-item的rules属性定义它的校验规则。该属性可以接受一个或多个校验规则对象，用于指定该表单项的验证条件。
            4. 当用户输入数据时，会触发el-input组件的change事件。在组件实例中监听该事件，并通过调用$refs.form[0].validate方法来进行表单验证。该方法会返回一个Promise对象，用于异步处理表单验证结果。
            5. 如果表单验证成功，则会触发submit事件；如果验证失败，则会在当前表单元素上显示错误信息。
        总体来说，elementui的表单验证方式比较简单易懂，同时支持多种校验规则和自定义错误提示信息，能够满足大部分业务需求。
#    8.vue如何进行组件通信？
        在 Vue.js 中，组件通信可以通过以下几种方式实现：
            1. Props 和 $emit:父组件通过 props 属性向子组件传递数据，子组件可以通过 $emit 方法向父组件发送事件。这种方式适用于父子组件之间的单向数据传递和事件通信。
            2. $parent 和 $children:在某些情况下，需要直接访问子组件实例的属性和方法。这时可以使用 $parent 和 $children 属性。$parent 可以访问当前组件的直接父组件实例，而 $children 可以访问当前组件的所有子组件实例。
            3. $refs:通过给子组件绑定 ref 属性，可以在父组件中获取到子组件的实例，并调用其方法或修改其属性。这种方式适用于需要在不同组件之间传递引用对象的情况。
            4.provide/inject:，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效
            5. Vuex:Vuex 是 Vue.js 的状态管理库，可以用来管理应用的所有状态。通过创建一个 Vuex store,可以将状态统一管理起来，并通过 Vuex 提供的方法来进行状态共享和通信。这种方式适用于多个组件之间需要共享全局状态的情况。
        以上是常用的几种组件通信方式，具体使用哪种方式取决于具体的业务需求。
    9.keep-alive是什么？怎么使用？
        keep-alive 是 Vue.js 提供的一个组件，用于缓存被包含在 <keep-alive> 内部的组件实例，以便在切换组件时可以避免重复渲染。
    10.axios是怎么做封装的？    
        1.可以使用 axios.create() 方法创建一个 axios 实例，并在其中设置一些默认配置，例如请求头、超时时间等。这种方式可以帮助我们避免在每次发送请求时都重复设置这些配置项。
        2.service.interceptors.request 配置请求拦截
        3.service.interceptors.response 配置响应拦截
        4.模块化导出
    11.vue路由时怎么传参的？
        在 Vue 路由中，可以通过 `route` 对象来传递参数。具体来说，可以在路由配置对象中定义一个 `path` 属性，该属性值为路由路径，例如：
        ```javascript
            const router = new VueRouter({
            routes: [
                {
                path: '/user/:id',
                component: UserComponent,
                props: true
                }
            ]
            });
        ```
#    12.vue路由的hash模式和history模式有什么区别？
        1.hash模式: url带#号,兼容性强,不符合w3c规范,对搜索引擎不友好,通过监听hashChange事件来修改页面
        2.history: url不带#号,兼容性稍弱,符合w3c规范,对搜索引擎友好,通过history.pushState()方法或者history.replaceState()通过修改浏览器的历史记录来实现的。
#    13.路由拦截是怎么实现的？
        Vue 路由拦截是通过在路由器实例中配置一个导航守卫(Navigation Guard)来实现的。导航守卫是一个函数，它会在用户尝试访问某个页面时被调用。在这个函数中，我们可以对用户的访问进行拦截和处理，比如验证登录状态、权限控制、重定向等等.
        1：全局守卫： beforeEach、 afterEach
        2：独享守卫（单个路由里面的钩子）： beforeEnter、 beforeLeave
        3：组件内守卫：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave
        每个守卫方法接收三个参数：
            ①to: Route: 即将要进入的目标路由对象（to是一个对象，是将要进入的路由对象，可以用to.path调用路由对象中的属性）
            ②from: Route: 当前导航正要离开的路由
            ③next: Function: 这是一个必须需要调用的方法，执行效果依赖 next 方法的调用参数。
    14.说一下vue的动态路由。
        是指根据用户当前的权限,由后台返回相应的路由信息,然后通过router.addRoutes方法添加到当前的路由中动态渲染导航栏
    15.如何解决刷新后二次加载路由？
        1.使用浏览器的缓存机制:在刷新页面时，如果路由信息已经存在于浏览器缓存中，那么我们不需要再次加载它们。我们可以使用Vue的keep-alive组件来缓存我们的组件，以确保它们在页面刷新时仍然存在。
        2.手动重新加载路由:我们可以使用$route.reload()方法来重新加载当前路由。这个方法会销毁当前路由并创建一个新的路由实例，从而使我们能够重新获取最新的数据。
    16.vuex刷新数据会丢失吗？怎么解决？
        会  
        1.直接在vuex修改数据方法中将数据存储到浏览器本地存储中
        2.vuex-persistedstate第三方库缓存
#    17.computed和watch的区别？
        computed和watch都是Vue实例中的方法，用于处理数据的变化。它们的区别在于：
            1. computed是计算属性，watch是观察者。
            computed是用来计算数据的值的，它根据其他数据的变化自动更新计算结果。比如，我们可以使用computed来获取一个商品的总价、数量等信息。
            watch则是用来监听其他数据的变化，当某个数据变化时，watch会执行相应的回调函数，以便我们可以对数据进行处理。比如，我们可以使用watch来监听用户输入的价格变化，以便实时计算出折扣后的价格。
            2. computed具有缓存功能，watch不具有缓存功能。
            computed的返回值会被缓存起来，只有当依赖的数据发生变化时才会重新计算。这意味着如果依赖的数据没有发生变化，computed的返回值将不会改变。这种缓存机制可以提高性能，减少重复计算。
            watch则没有缓存功能，每次监听都会重新执行回调函数。这意味着如果依赖的数据没有发生变化，watch的回调函数仍然会被调用。这种机制可能会影响性能，特别是在监听大量数据时。
            3. computed可以用来定义常量和方法。
            computed可以返回一个常量或方法，这样我们就可以在模板中使用这些常量或方法，而无需每次都去计算它们的值。比如，我们可以使用computed来定义一个商品的单价常量和计算总价的方法。
            watch则只能用来监听数据的变化，不能用来定义常量或方法。
        综上所述，computed和watch都是用来处理数据变化的方法，但它们的用途和机制有所不同。computed适用于计算一些固定值或返回一些固定方法的情况，而watch适用于监听某些数据的变化并做出相应处理的情况。
#    18.vuex在什么场景会去使用？属性有哪些？
        Vuex是一个专门为Vue.js应用程序开发的状态管理库。它可以帮助我们更好地组织和管理应用程序中的数据，从而提高应用程序的可维护性和可扩展性。
        以下是一些常见的使用Vuex的场景：
            1. 当应用程序需要共享状态时，例如在多个组件之间共享数据。
            2. 当应用程序需要处理复杂的业务逻辑时，例如在订单系统中处理订单的相关操作。
            3. 当应用程序需要进行跨页面通信时，例如在登录和注册页面之间传递用户信息。
        下面是Vuex的一些常用属性：
            1. state:用于存储应用程序中的状态数据。
            2. getters:用于获取state中的数据，并根据特定的条件对其进行计算和转换。
            3. mutations:用于更新state中的数据，通常用于执行异步操作或对数据进行复杂的处理。
            4. actions:用于触发mutations来更新state中的数据，通常用于执行与服务器端交互的操作。
            5. modules:用于组织和管理应用程序中的不同状态和功能模块。
        总之，Vuex适用于需要管理复杂状态和进行跨页面通信的Vue.js应用程序。通过合理地使用Vuex的属性和功能，可以使应用程序更加清晰、易于维护和扩展。
    19.vue的双向数据绑定原理是什么？
        Vue.js使用数据双向绑定的原理是基于Object.defineProperty()方法实现的。当一个Vue实例被创建时，它会遍历data对象中的所有属性，并使用Object.defineProperty()方法将它们转换为getter和setter函数。
        在getter函数中，Vue会跟踪哪些属性被访问了，以及它们的值是如何变化的。当用户对该属性进行输入时，setter函数会被调用，并且Vue会自动更新相关的视图。同样地，当用户修改了该属性的值时，setter函数会再次被调用，并且Vue会自动更新相关的视图。
        这种双向绑定的实现方式使得Vue可以非常高效地追踪数据的变化，并自动更新视图，从而实现了非常简便、高效的数据绑定功能。同时，由于Vue使用了响应式的机制来监听数据的变化，因此它也具有很好的性能表现，可以在处理大量数据时保持流畅的交互体验。
#    20.了解diff算法和虚拟DOM吗？
        1. diff算法：在Vue中，当组件的状态发生变化时，Vue会通过比较新旧状态的差异来计算出需要更新哪些具体的DOM元素。这个过程就是diff算法。
        与React中的diff算法类似，Vue的diff算法也是通过深度优先遍历树形结构，将新旧状态的差异分为三个阶段进行处理：
            * 第一阶段：新旧节点的标记阶段。Vue会对新旧节点进行标记，以便后续比较。
            * 第二阶段：新旧节点的差异比较阶段。Vue会对新旧节点进行深度优先遍历，比较它们的属性和子节点是否相同，如果有不同则进行相应的更新操作。
            * 第三阶段：新旧节点的替换阶段。Vue会根据差异结果将新节点替换掉旧节点。
        通过这种方式，Vue可以高效地更新DOM,并且只更新必要的部分，从而提高了应用程序的性能和响应速度。
        2. 虚拟DOM:虚拟DOM也是一种内存中的表示方式，它可以模拟真实DOM的行为。在Vue中，虚拟DOM被用来提高渲染性能。
        当Vue需要更新DOM时，它会先创建一个新的虚拟DOM树，然后通过对新旧虚拟DOM树的差异进行比较来确定需要更新哪些具体的DOM元素。由于虚拟DOM是在内存中维护的，因此在更新DOM时不需要重新渲染整个页面，而只需要更新需要更新的部分，从而提高了应用程序的性能和响应速度。
    21.vue和jquery的区别是什么？
        1.jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，数据和界面是在一起的。
        2.Vue则是把值和js对象进行绑定，然后修改js对象的值，Vue框架就会自动把dom的值就行更新。对数据进行操作不再需要引用相应的DOM对象
        3.最明显的就是思维方式不同，jquery 是以操作dom为主，做了数据处理之后还需要对dom进行操作。vue.js是以操作数据为主，不操作dom，也就是传说中的双向数据绑定，你只需要操作数据就好，dom自动更新。这只是对初学者来说最大的不同。jquery只是一个类库，只是提供了很多的方法，不能算框架，而vue.js是一个框架，有一套完整的体系。
    22.vuex的响应式处理。
        Vuex是Vue.js的状态管理库，它提供了一种响应式的数据管理方式。在Vuex中，所有状态都存储在一个store对象中，而这个store对象又被称为Vuex的state。
        当一个mutation方法被调用时，它会直接修改store中的state,而不需要手动更新每个组件中的状态。这是因为Vuex使用了一种基于代理的观察者模式(Observer Pattern),它可以自动追踪store中的状态变化，并通知所有依赖于这个状态的组件进行更新。
        具体来说，当一个mutation方法被调用时，Vuex会执行以下步骤：
        1. Vuex会将mutation方法添加到当前上下文的commit方法队列中。
        2. 当当前组件被更新时，Vuex会检查当前上下文的commit方法队列中是否有mutation方法，如果有，则依次执行这些方法。
        3. 在执行mutation方法的过程中，Vuex会自动追踪store中的状态变化，并通知所有依赖于这个状态的组件进行更新。
        总之，Vuex通过使用响应式处理的方式来实现数据的自动同步更新，使得开发人员可以更加专注于业务逻辑的实现，而不必手动处理复杂的数据管理问题。
    23.vue中遍历全局的方法有哪些？
        在Vue中，有多种遍历全局数据的方法，以下是其中几种常用的方法：
            1. this.$refs:通过this.$refs获取到组件的实例对象，然后使用实例对象访问组件中的数据。
            2. this.$parent:通过this.$parent访问到组件的父组件实例，然后使用父组件实例访问父组件中的数据。
            3. this.$children:通过this.$children访问到当前组件的所有子组件实例，然后使用子组件实例访问子组件中的数据。
            4. Vue.get:通过Vue.get获取全局状态中的数据。
            5. Vuex.store.state:通过Vuex store获取全局状态中的数据。
            6. this.$data:通过this.$data访问组件实例中的数据。
        需要注意的是，在使用这些方法时应该确保数据的正确性和有效性，避免出现安全问题和性能问题。同时，也应该根据具体情况选择合适的遍历方式，以提高代码的可读性和可维护性。
    24.如何搭建脚手架？
        安装 Node.js Vue-Cli 
    25.如何封装一个组件？
    26.封装一个可复用的组件，需要满足什么条件？
        1. 可重用性：组件应该可以在其他地方被调用和使用。组件应该具有一定的独立性，而不是仅仅作为一个功能模块的一部分。
        2. 可扩展性：组件应该可以被添加新的功能或修改现有功能而无需修改其底层代码。这将使组件在未来更加灵活和易于维护。
        3. 可配置性：组件应该能够接受不同的参数和选项，以便在不同的场景下进行自定义。这将使组件更具有通用性和适应性。
        4. 可测试性：组件的代码应该具有良好的测试覆盖率，以确保它的功能是可靠的。这将使组件在未来更容易进行维护和升级。
        5. 可读性和可维护性：组件的代码应该易于阅读和理解，并且应该遵循一致的命名约定和代码风格。这将使组件更易于维护和扩展。
    27.vue的过滤器怎么使用？
    28.vue中如何做强制刷新？
        1.$forceUpdate() 方法来强制刷新组件。
        2.v-if
        3.key
#    29.vue3和vue2有哪些区别？
        Vue 3 和 Vue 2 有以下几个区别：
            1. 性能提升：Vue 3 在编译器、渲染器和运行时等方面都有很大的性能提升，特别是在响应式数据更新方面比 Vue 2 更高效。
            2. Composition API:Vue 3 引入了全新的 Composition API,它可以更好地组织组件逻辑，使得代码更加清晰、可读性更高。
            3. TypeScript 支持：Vue 3 对 TypeScript 的支持更加完善，包括类型推断、类型检查等功能。
            4. Tree shaking:Vue 3 在编译时会进行更好的 Tree shaking,可以减少不必要的代码体积。
            5. VNode 的改进：Vue 3 对 VNode 进行了一些改进，比如增加了更多的 props、事件、指令等特性。
            6. 模板语法变化：Vue 3 的模板语法有一些变化，比如 v-bind、v-on、v-model 这些指令的语法有所改变。
        总的来说，Vue 3 在性能、功能和 API 等方面都有较大的改进和优化，同时也带来了一些新的挑战和学习成本。
#    30.vue的性能优化怎么做？
        Vue 的性能优化可以从以下几个方面入手：
            1. 使用虚拟 DOM:Vue 通过虚拟 DOM 来减少实际 DOM 操作的次数，从而提高渲染性能。可以使用 Vue 提供的指令和 API,手动更新虚拟 DOM,也可以使用 Vue 的响应式系统自动更新虚拟 DOM。
            2. 使用异步渲染：如果需要在页面加载完成后才能获取到数据，可以考虑使用 Vue 的异步组件或者异步路由，这样可以避免不必要的渲染和数据重新加载。
            3. 避免重复渲染：Vue 中如果有相同的组件或者数据，只会渲染一次，可以通过使用 computed 或者 watch 监听数据变化来避免重复渲染。
            4. 避免过多的嵌套：如果组件嵌套过多，会导致渲染性能下降。可以尝试将组件进行拆分或者重构，减少嵌套层数。
            5. 避免使用过多的计算属性：计算属性会增加渲染的开销，如果计算量很大，可以考虑使用 Vuex 或者手动管理状态来避免计算属性的使用。
            6. 避免使用过多的事件监听器：事件监听器会增加页面的负担，如果事件比较频繁或者数量较多，可以考虑使用事件代理或者节流限流来避免性能问题。
            7. 使用缓存：如果需要频繁读取数据，可以考虑将数据缓存起来，避免重复读取。可以使用浏览器缓存或者 Vue 提供的本地存储来实现数据的缓存。
        总之，Vue 的性能优化需要综合考虑多个方面，包括虚拟 DOM、异步渲染、组件拆分、事件管理等等，需要根据具体情况进行针对性优化。
#    31.首屏优化该如何去做？
        首屏优化是指在用户打开网页时，尽可能快地展示出主要内容，以提高用户体验和页面的吸引力。以下是一些常见的首屏优化方法：
            1. 压缩图片：将图片进行压缩可以减小文件大小，加快页面加载速度。可以使用在线图片压缩工具或者图片编辑软件进行压缩。
            2. 减少 HTTP 请求：通过减少 HTTP 请求次数可以加快页面加载速度。可以将多个 CSS 或 JavaScript 文件合并成一个，或者使用 CSS Sprites 将多个图片合并成一个。
            3. 懒加载：对于大量数据或者复杂的页面结构，可以使用懒加载技术，只有当用户需要访问这些数据或者页面结构时才进行加载，以避免一次性加载过多的数据导致页面卡顿。
            4. 移动端优化：对于移动端用户来说，首屏加载速度非常重要。可以通过优化图片、减少 HTTP 请求、使用缓存等方式来提高移动端首屏加载速度。
            5. 快速响应：页面加载完成后尽快显示主要内容，避免用户等待时间过长。可以使用 AJAX 或者 WebSockets 实现异步加载数据，以提高页面响应速度。
        总之，首屏优化是一个综合性的问题，需要综合考虑多个方面，包括图片压缩、HTTP 请求、懒加载、移动端优化等等。根据具体情况选择合适的优化方法可以提高页面的性能和用户体验。
#    32.vue3的性能为什么比vue2好？
        Vue 3 相比于 Vue 2,在性能方面有以下几个方面的提升：
            1. 编译器优化：Vue 3 的编译器进行了全面的优化，包括静态树转换、虚拟 DOM 重写、模板语法改进等等。这些优化可以减少运行时的渲染时间和操作次数，提高页面性能。
            2. 更小的体积：Vue 3 在体积上比 Vue 2 更小，因为它移除了一些不必要的功能和 API,同时使用了更小的代码库来实现相同的功能。这使得 Vue 3 可以更快地加载和执行。
            3. 更好的响应式系统：Vue 3 的响应式系统相比于 Vue 2 更加高效和灵活。Vue 3 采用了新的响应式原理，即基于Proxy的响应式系统，可以在运行时更好地追踪数据的变化，从而提高性能。
            4. 更好的虚拟 DOM:Vue 3 对虚拟 DOM 进行了优化，采用了更快的 diff 算法和更细粒度的变更检测，从而提高了渲染性能。此外，Vue 3 还提供了新的 batchedUpdates API,可以更好地控制更新频率，进一步提高性能。
        总之，Vue 3 在编译器、体积、响应式系统和虚拟 DOM 等方面都进行了优化，从而提高了性能表现。但是需要注意的是，性能的提升也与具体的应用场景和使用方式有关，需要综合考虑多个因素来做出选择。
    33.vue3为什么使用proxy？
        Object.defineProperty(obj, prop, descriptor)无法监听到对象的新增和删除
    34.说一下你对组件的理解。
        组件是 Vue.js 框架中的一个重要概念，用于将一个完整的 UI 界面划分为多个可重用的、独立的部分。每个组件都是一个具有自己属性和方法的独立对象，它们可以被多次使用，并且可以嵌套在其他组件中。
        在 Vue.js 中，组件通常由以下几个部分组成：
            1. HTML 模板：组件需要提供一个 HTML 模板，用于描述组件的结构和样式。
            2. JavaScript 代码：组件需要包含一些 JavaScript 代码，用于定义组件的行为和逻辑。这些代码通常包括 props、methods、data 等属性和方法。
            3. CSS 样式：组件需要提供一些 CSS 样式，用于定义组件的外观和布局。这些样式可以单独写在一个 CSS 文件中，也可以写在组件的 HTML 模板中。
        在 Vue.js 中，我们可以通过创建一个新组件来使用它，也可以通过引入已有的组件来使用它。一旦我们使用了一个组件，它的实例就会被缓存起来，下次再使用时就可以直接从缓存中获取，而不需要重新创建。这样可以大大提高应用程序的性能。
    35.你是如何规划项目文件的？
    36.是否使用过nuxt.js？
#    37.SEO如何优化？
        Vue.js是一个流行的JavaScript框架，用于构建单页面应用程序(SPA)。在优化Vue.js网站的SEO方面，以下是一些常见的技巧：
            1. 确保你的Vue.js应用程序是响应式的。这意味着用户可以通过任何设备从任何地方访问你的网站，并且它将自动适应不同的屏幕大小。
            2. 在Vue.js应用程序中使用预渲染组件。这可以提高搜索引擎爬虫的效率，因为它们可以更快地抓取和索引您的网站。
            3. 使用服务器端渲染(SSR)来生成HTML内容。这可以确保搜索引擎爬虫能够抓取完整的HTML内容，而不是只看到JavaScript代码。
            4. 在Vue.js应用程序中使用路由来控制URL结构。确保每个页面都有一个唯一的URL,并使用适当的路由模式来组织您的网站。
            5. 在Vue.js应用程序中使用预加载来加速页面加载速度。这包括预加载必要的CSS和JavaScript文件，以及在用户进入页面之前预加载其他资源。
            6. 确保您的Vue.js应用程序有一个清晰的网站地图，以便搜索引擎可以轻松地找到和索引您的网站上的所有页面。
            7. 在Vue.js应用程序中使用meta标签来描述您的网站和页面的内容，以帮助搜索引擎了解其主题和目的。
        总之，优化Vue.js网站的SEO需要综合考虑多个因素，包括网站的结构、内容、性能和可访问性等方面。

五、Echarts
    1.echarts有用过吗？常用的组件有哪些？
        作为一个AI语言模型，我没有实际的使用经验，但我可以告诉你一些关于echarts的信息。
        Echarts是一个基于JavaScript的数据可视化库，它提供了丰富的图表类型和交互功能，可以帮助开发者快速构建各种类型的数据可视化应用程序。以下是一些常用的echarts组件：
            1. 柱状图：可以用于显示数据的分布情况，例如数量、比例等。
            2. 折线图：可以用于显示时间序列数据的变化趋势。
            3. 散点图：可以用于显示两个变量之间的关系。
            4. 饼图：可以用于显示数据的占比情况。
            5. 地图：可以用于显示地理信息，例如国家、城市等。
            6. 热力图：可以用于显示数据的密度分布情况。
            7. 雷达图：可以用于显示多维数据的分布情况。
        除了这些基本的组件外，echarts还提供了很多高级的功能和定制化选项，可以根据不同的需求进行灵活的配置和扩展。同时，echarts也支持多种数据源格式，包括JSON、XML、CSV等，可以方便地与其他系统集成。
六、Uni-APP
    1.uni-app有没有做过分包？

七、Weabpack
    1.webpack打包和不打包的区别？
    2.webpack是怎么打包的，babel是做什么的？

八、Git
    1.git如何合并、拉取代码？
    2.git如何解决冲突问题？

九、HR
    1.你的离职原因是什么？
    2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？
    3.你的优势在哪里？
    4.如何协同工作？
